## 加法运算符
JavaScript 允许非数值的相加：true + true //2
非数值的相加，会自动转为数字。但两个字符串的相加，加号就会变成连接运算符，返回一个新的字符串。
1 + ‘a’  //'1a' 非字符串会变成字符串再相加

加法运算符是在运行时决定，到底是执行相加，还是执行连接。也就是说，运算子的不同，导致了不同的语法行为，这种现象称为“重载”（overload）。只有加法运算符，其他算数运算符不会有重载。

‘3’ + 4 + 5 //字符串在前面，后面的就编程字符串再相加

3 + 3 + ‘5’  //字符串再后面，前面的数字会先相加，再变成字符串与后面的字符串相加。

如果运算子是对象，必须先转成原始类型的值，然后再相加。

var obj = {p: 1};
obj + 2  //'[object Object]2'

自定义 valueOf 方法：

var obj = {
	valueOf: function(){
		return 1;
	}
};

obj + 2 //3

对象转原始类型的值的过程是：先 valueOf 再 toString。

运算之后，变量的值发生变化，这种效应叫做运算的副作用（side effect）。自增和自减运算符是仅有的两个具有副作用的运算符，其他运算符都不会改变变量的值。

自增和自减运算符有一个需要注意的地方，就是放在变量之后，会先返回变量操作前的值，再进行自增/自减操作；放在变量之前，会先进行自增/自减操作，再返回变量操作后的值。

+ 加号同时也是数值运算符，作用是将任何值转为数值。与 Number 的作用一样。
+ true //1
+ []  //0
+ {}  //NaN

负数值运算符也有同样的效果，把xx转为数值。
var x = 1;
-x //-1
-(-x) //1  这里的括号不能省，否则会被当成自减运算符。

指数运算符
2**4  //16
2**3**2  //512  注意，指数运算符是右结合。意思是先进行右边的计算。左例就是这样。

# 比较运算符
2 > 1 //true

比较运算符还可以比较各种类型的值，不只是数值。

Javascript 一共提供了 8 个比较运算符

> < <= >= == === != !==

对于非相等的比较，算法是先看两个运算子是否都是字符串，如果是的，就按照字典顺序比较（实际上是比较 Unicode 码点）；否则，将两个运算子都转成数值，再比较数值的大小。

这里需要注意与NaN的比较。任何值（包括NaN本身）与NaN比较，返回的都是false。

简单说，它们的区别是相等运算符（==）比较两个值是否相等，严格相等运算符（===）比较它们是否为“同一个值”。如果两个值不是同一类型，严格相等运算符（===）直接返回false，而相等运算符（==）会将它们转换成同一个类型，再用严格相等运算符进行比较。

需要注意的是，NaN与任何值都不相等（包括自身）。另外，正0等于负0。
undefined = undefined
undefined
undefined == du
undefined == undefined
true
var v1;
var v2;
v1 ===v2
true


