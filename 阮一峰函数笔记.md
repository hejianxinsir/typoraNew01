1. 函数作用域：全局作用域 和 局部作用域。

2. 全句作用域，即任何地方都能调用那个变量；局部作用域，就是在函数内部声明的变量，这个变量只能在函数内部使用。

3. 在局部作用域外面，不能调用局部作用域里的变量；如果局部作用域里的变量和外部变量同名，那么在该作用域内，里面的变量会覆盖外面的变量。这也是一个优先级的问题，在内部，自然是内部的变量优先。

- 注意，对于 var 命令来说，局部变量只能在函数内部声明，在其他地方声明的变量，都是全局变量。

4. 函数的 length 属性只返回函数预期传入的参数个数，与你实际给该函数的参数个数无关；函数的 name 属性，返回函数名。
```
function print(){}  //print.name 即 print

var print = function(){}  //print.name 即 print

var print = function x(){}  //print.name 即 x 。但 x 只能在函数体内部使用。真正的 name 还是 print 。
```

5. 函数的 toString 属性返回函数的源码，即 函数是什么样子就返回什么样子；另，对 JavaScript 提供的原生函数，返回 // "function sqrt() { [native code] }"

6. 函数内部声明的变量，也会有变量提升。

7. 函数本身也是一个值，函数执行时的作用域是声明时的作用域，而不是函数内部的作用域。
```
var x = function () {
  console.log(a);
};

function y(f) {
  var a = 2;
  f();
}

y(x)   // ReferenceError: a is not defined

请问，为什么 a is not defined ？

是这样的。首先执行 y(x), 此时到了第二个函数的内部，接着执行了 x() , 此时到了第一个函数，即执行 console.log(a) , 但是只有第二个函数才声明了 a=2 ，可第一个函数是读取不到这个 a 的，所以 a 没有被定义。
```

8. 函数的参数可以都省略，但如果值省略第一个，其他的不省略，就会报错。如果一定要省略第一个参数，可以显式的把第一个参数写成 undefined .

9. 函数参数如果是原始类型的值（数值、字符串、布尔值），传递方式是传值传递（passes by value）。这意味着，在函数体内修改参数值，不会影响到函数外部。

10. 但是，如果函数参数是复合类型的值（数组、对象、其他函数），传递方式是传址传递（pass by reference）。也就是说，传入函数的原始值的地址，因此在函数内部修改参数，将会影响到原始值。



